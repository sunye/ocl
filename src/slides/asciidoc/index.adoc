
include::./includes/commons.adoc[]
= OCL: The Object Constraint Language

//Gerson Sunyé <gerson.sunye@univ-nantes.fr>

 
== License


This work is licensed under a http://creativecommons.org/licenses/by-nc/4.0/[Creative Commons Attribution-NonCommercial 4.0 International License].

http://creativecommons.org/licenses/by-nc/4.0/[image:https://i.creativecommons.org/l/by-nc/4.0/88x31.png[Creative Commons License]]


== Plan

[arabic]
. *Introduction*
. Invariants
. Model Navigation
. Types and Operations
. Property Definition
. Operation Specification
. Advanced Topics
. Conclusion
. Appendix - Language Details



[.impact]
== Introduction


== What is OCL?

OCL stands for «Object Constraint Language».

.OCL is: 
* a OMG standard (see http://www.omg.org/spec/OCL/). 
* a formal and unambiguous language, but easy to use (even for non mathematicians). 
* a complement to UML (and also to MOF, but that is another history).


== Why do I need OCL? 

Sometimes, the UML lacks precision. Suppose the following class diagram:

image::family.png[align=center,width=400px]

* How do you specify that this class only considers people born after 1900? 
* And how do you specify that cycles are not allowed (i.e., that a person cannot be an ancestor of himself)?


[.columns]
== What About Comments?

[.column.is-half]
--
image::marriage.png[align=center,width=600px]

image::anna-bob-carol.png[align=center,width=600px]
--

[.column]
* Comments, expressed in natural languages, are often very useful.
* But sometimes, they are also ambiguous.
* Still, comments cannot avoid some situations.

== How can OCL add more precision to UML?

* By adding _constraints_ to modeling elements:
 
[source,ocl]    
----
context Person
inv: self.wife->notEmpty() implies self.wife.husband = self and
    self.husband->notEmpty() implies self.husband.wife = self
----

image::marriage.png[align=center,width=800px]

== Plan

[arabic]
. Introduction
. *Invariants*
. Model Navigation
. Types and Operations
. Property Definition
. Operation Specification
. Advanced Topics
. Conclusion
. Appendix - Language Details



[.impact]
== Invariants

== Class Invariants
* A class invariant is a constraint that must be verified by all instances of a class, when in a *stable state*.
* The notion of stable state is important: an invariant may be broken during the execution of an operation.
* It is commonly accepted that an instance is in a stable state between the execution of two public operations.

== Invariants: Graphical Notation

* Invariants can be placed directly on the modeling element, between braces ({}) or on a comment attached to it:

image::person-inv.png[align=center,width=400px]

image::person-inv-note.png[align=center,width=800px]

== Invariants: Textual Notation

Invariants may also be placed on a separate document. In this case, the notion of *context* is important.

[source,ocl]
----
context Person inv: self.age < 150 

context Person inv: age < 150
----


== «Context»

* Every OCL expression is attached to a specific *context*: a UML modeling element.
* The context may be referenced inside the expression using the `+self+` keyword.

[plantuml,align=center]
----
scale 1024 width
scale 800 height
hide circle

class "Person\n {age > 0 and age < 150}" as person {
	+ name : String
	+ age : Integer
}
----

[source,ocl]
----
context Person inv: self.age < 150
context Person inv: self.age > 0
----

[.columns.is-vcentered]
== Context Properties

[.column]
--
* The context allows the access to some properties from the attached modeling element.
* In the case of a UML class, this means: attributes, query operations, and states (from attached state machines).
--

[.column]
--
[plantuml,, svg, align=center, width=400px]
----
hide circle

class "Person" {
    + birthday : Date
	+ firstName : String
	+ lastName : String
    + gender : enum {male, female}
	+ age() : Integer
}
----

[source,ocl]
----
context Person
inv:
  self.name.size() > 1 and
  self.age() >= 0 and
  self.oclInState(Single)
----
--

[.notes]
--
While it is possible to check a state within an invariant, this is not logical.
--


== Plan 

. Introduction 
. Invariants 
. *Model Navigation* 
. Types and Operations
. Property Definition 
. Operation Specification 
. Advanced Topics 
. Conclusion 
. Appendix - Language Details

[.impact]
== Model Navigation

[.columns]
== OCL & UML: Basic Principles

[.column.is-half]
--
* OCL expressions have no side effect, they cannot modify the model.
* A OCL expression refers to the following constituents:
** Values of basic types: `+Integer+`, `+Real+`, `+Boolean+`, `+String+`, `+UnlimitedNatural+`;
** Modeling elements, from the associated UML model;
** Collections of values or modeling elements.
--

[.column]
image::university.svg[width=800px,align=center]

== Operation Call Syntax

* Operation calls on elements and values use *dots*:

[source,ocl]
----
'Nantes'.substring(1,3) = 'Nan'
----

* Operation calls on collections use *arrows*:

[source,ocl]
----
{1, 2, 3, 4, 5}->size() = 5
----


== Role Navigation

An OCL expression can navigate through model associations using the opposite role (association end):

[plantuml,,svg, align=center,width=800px]
....
hide circle
class University {
    name: String
}
class Department {
    name: String
    add(Professor)
}
University "[1]\n university" - "[*]\n departments" Department : \t\t\t\t\t
....

[source,ocl]
----
context Department 
    -- A department's university should not be null. 
    inv: not self.university.oclIsUndefined()

context University
    -- A university must have at least one department 
    inv: self.departments->notEmpty() 
----
    
[.notes]
--
Navigation through private roles is possible. 
It seems that it is also possible to navigate through non-navigable roles.
--

[.columns]
== Multiplicities

[.column.is-one-third]
--
image::course.svg[align=center,width=600px]
--

[.column]
--
.The type of an expression (its return type) depends on the role’s maximum multiplicity:
* If equals to 1, it's a simple element.
* If > 1, it's a collection.

[source,ocl]
----
context Course
  -- an objet:
  inv: self.instructor.oclInState(Available)

  -- a collection (Set):
  inv: self.is_mastered_by->notEmpty()
----
--

[.columns]

== Navigation: Special Cases

[.column.is-one-third]
--

image::department-professor.svg[align=center,align=400px]

image::wife.svg[align=center,align=400px]
--

[.column]
--
* When there is no role name, the OCL uses the class name (in lower cases).
* Monovalued (max multiplicity = 1) roles may be navigated as a collection.

[source,ocl]
----
context Department inv: self.chef->size() = 1

context Department inv: self.chef.age > 40

context Person inv: self.wife->notEmpty()
    implies self.wife.gender = Gender::female
----

--

== Navigation through Association-Classes

* To navigate towards an association-class, OCL uses the association-class’ name, in lower cases.

[source,ocl]
----
context Student
inv:
    -- A student average grade is always greater than 4:
    self.grade.value->average() > 4
----

image::grade.svg[align=center,width=800px]


== Navigation through Association-Classes

* To navigate from class-association, OCL uses role names:

[source,ocl]
----
context Grade inv:
    self.students.age() >= 18
    self.follows.hours > 3
----

image::grade.svg[align=center,width=800px]


== Qualified Associations

image::qualified-association.svg[align=center,width=800px]


* To navigate through a qualified association, OCL uses the qualifier name between square brackets:

[source,ocl]
----
context University
    -- The name of student 8764423 must be 'Martin'.
    inv: self.students[8764423].name = 'Martin'
----

* When the qualifier is not specified, the result is a collection:

[source,ocl]
----
context University
    -- There is at least one student named 'Martin':
    inv: self.students->exists(each | each.name = 'Martin')
----

[.impact]
== Plan

[arabic]
. Introduction
. Invariants
. Model Navigation
. *Types and Operations*
. Property Definition
. Operation Specification
. Advanced Topics
. Conclusion
. Appendix - Language Details

[.impact]
== Types and Operations


== Basic Types

[cols=",",options="header",]
|===
|Type | Values

|`OclInvalid` | invalid
|`OclVoid` | null, invalid
|`Boolean` | true, false
|`Integer` | 1, -5, 2, 34, 26524, etc.
|`Real` | 1.5, 3.14, etc.
|`String` | 'To be or not to be...'
|`UnlimitedNatural` | 0, 1, 2, 42, ... , *
|===


== Collection Types (1/2)

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
| Type | Description |Obtained from |Examples
|`+Set+` |unordered set. |Simple navigation | {1, 2, 45, 4}
|`+OrderedSet+` |ordered set. |Navigation through an ordered association end (labelled with `+{ordered}+`) | {1, 2, 4, 45}
|===

== Collection Types (2/2)

[width="100%",cols="25%,25%,25%,25%",options="header",]
|===
| `+Type+` |Description |Obtained from |Examples
| `+Bag+` |unordered multiset. |Combined navigations | {1, 3, 4, 3}
| `+Sequence+` |ordered multiset. |Navigation though a ordered association end `+{ordered}+` | {1, 3, 3, 5, 7},  {1..10}
|===

== Type Conformity Rules

[cols=",,",options="header",]
|===
|Type |Conforms to |Condition

|`Set(T1)` 
| `Collection(T2)` 
|If `T1` conforms to `T2`

|`Sequence(T1)` 
| `Collection(T2)` 
| If `T1` conforms to `T2`


|`Bag(T1)` 
| `Collection(T2)` 
| If `T1` conforms to `T2`

|`OrderedSet(T1)` 
| `Collection(T2)` 
| If `T1` conforms to `T2`

| `Integer` 
| `Real`
|
|===


== Operations on Basic Types

[width="100%",cols="50%,50%",options="header",]
|===
|Type |Operations

|`+Integer+` 
| `=, *, +, -, /, abs(), div(), mod(), max(), min()`

|`+Real+` 
| `=, *, +, -, /, abs(), floor(), round(), max(), min(), >, <, <=, >=, ...`

|`+String+` 
| `=, size(), concat(), substring(), toInteger(), toReal(), toUpperCase(), toLowerCase()`

|`+Boolean+` 
| `or, xor, and, not, implies`

|`+UnlimitedNatural+` 
| `*, +, /`
|===


== Operations on Collections

[cols=",",options="header",]
|===
|Operations |Behavior
|`+isEmpty()+` |True if the collection is empty.
|`+notEmpty()+` |Trues if the collection contains at least one element.
|`+size()+` |Number of elements in the collection.
|`+count(<elem>)+` |Number of occurrences of `+<elem>+` in the collection.
|===

.Examples:
[source,ocl]
----
{}->isEmpty()
{1}->notEmpty()
{1,2,3,4,5}->size() = 5
{1,2,3,4,5}->count(2) = 1
----



== Iterator Operations on Collections

Complex operations use an iterator (named `+each+` by convention), a variable that evaluates to each collection element.

[width="100%",cols="50%,50%",options="header",]
|===
|Operation |Behavior
|`+select(<boolean-expression>)+` |Selects (filters) a subset of the collection.
|`+collect(<expression>)+` |Evaluates an expression for each element in the collection.
|===

Examples:

[source,ocl]
----
{1,2,3,4,5}->select(each | each > 3) = {4,5}
{'a','bb','ccc','dd'}->collect(each | each.toUpper()) = {'A','BB','CCC','DD'}
----

'''''

== Select and Reject: Syntax

Selects (respectively rejects) the collection subset to which a boolean expression evaluates to true.

[source,ocl]
----
Collection(T)->select(elem:T | <bool-expr>) : Collection(T)
----

* The element types of the input and the output collections are always the same.
* The size of the output collection is less than or equal to the size of the input collection.


== Select and Reject: Examples

* Possible syntaxes:

[source,ocl]
----
context Department inv:
    -- no iterator
    self.instructors->select(age > 50)->notEmpty()
    self.instructors->reject(age > 23)->isEmpty()

    -- with iterator
    self.instructors->select(each | each.age > 50)->notEmpty()

    -- with typed iterator
    self.instructors->select(each : Professor | each.age > 50)->notEmpty()
----

== Collect: Syntax

Evaluates an expression on each collection element and returns another collection containing the results.

[source,ocl]
----
Collection<T1>->collect(<expr>) : Bag<T2>
----

* The sizes of the input and the output collection are mandatory the same.
* The result is a multiset (`+Bag+`).
* If the the result of `+<expr>+` is a collection, the result will not be a collection of collections. The result is automatically flattened.


== Collect: Examples

Possible syntaxes:

[source,ocl]
----
context Department:
    self.instructors->collect(name)
    self.instructors->collect(each | each.name)
    self.instructors->collect(each: Professor | each.name)

    -- Bag to Set conversion:
    self.instructors->collect(name)->asSet()

    -- shortcut:
    self.instructors.name
----

== Property Verification on Collections

[width="100%",cols="50%,50%",options="header",]
|===
|Operation |Behavior
|`+forAll(<boolean-expression>)+` |Verifies that *all* the collection elements respect the expression.
|`+exists(<boolean-expression>)+` |Verifies that *at least* the collection elements respect the expression.
|===

Examples:

[source,ocl]
----
{1,2,3,4,5}->forAll(each | each > 0 and each < 10)
{1,2,3,4,5}->exists(each | each = 3)
----


== For All: Syntax

Evaluates a Boolean expression on all elements of a collection and returns true if all evaluations return true.

[source,ocl]
----
Collection(T)->forAll(elem:T | <bool-expr>) : Boolean
----

== For All: Examples

[source,ocl]
----
context Department 
inv: 
    -- All instructors are associate professors. 
    self.instructors->forAll(title = Title::associate)
    
    self.instructors->forAll(each | each.titre = Title::associate)
    
    self.instructors->forAll(each: Professor | each.title = Title::associate)
----

== For All

Cartesian product:

[source,ocl]
----
context Department inv:
    self.instructors->forAll(e1, e2 : Professor |
        e1 <> e2 implies e1.name <> e2.name)

-- equivalent to:
    self.instructors->forAll(e1 | self.instructors->
        forAll(e2 | e1 <> e2 implies e1.name <> e2.name))
----


== Exists

Returns true if a boolean expression is true for at least one collection element.

Syntax:

[source,ocl]
----
collection->exists(<boolean-expression>) : Boolean
----

Example:

[source,ocl]
----
context: Department inv:
    self.instructors->exists(each: Professor |
        each.name = 'Martin')
----



== Plan 

. Introduction 
. Invariants 
. Model Navigation 
. Types and Operations
. *Property Definition* 
. Operation Specification 
. Advanced Topics 
. Conclusion 
. Appendix - Language Details


[.impact]
== Property Definition, Initialization, and Calculation


== Property Definition

* OCL allows the definition of new attributes and new operations, and add them to an existing class.
* These new properties can be used within other OCL constraints.

Syntax:

[source,ocl]
----
context <class-name>
  def: <attr-name> : <type> = <ocl-expression>
  def: <op-name> (<argument-list) : type = <ocl-expression>
----

[.columns]
== Property Definition

* Useful to decompose complex expressions without overloading the model.
* Examples:

[.column.is-two-thirds]
--

[source,ocl]
----
context Professor
def: students() : Bag(Student) =
    self.teaches.students

context Department
def: students() : Set(Student) =
    self.instructors.teaches.student->asSet()
----
--

[.column]
--
image::university.svg[align=center,width=600px]
--

== Property Initialization

* Initial value specification for attributes and roles.
* The expression type must conform to the attribute or role type.

Syntax:

[source,ocl]
----
context <class-name>::<prop-name>: <type>
    init: <ocl-expression>
----

Example:

[source,ocl]
----
context Professor::wage : Integer
    init: 800
----

[.columns]
== Derived Property Specification

[.column.is-one-third]
--
image::course.svg[align=center,width=600px]
--

[.column]
--

* OCL expression defining how a derived property is calculated.

Syntax:

[source,ocl]
----
context <class-name>::<role-name>: <type>
    derive:  <ocl-expression>
----

Examples:

[source,ocl]
----
context Professor::service : Integer
    derive: self.teaches.hours->sum()

context Person::single : Boolean
    derive: self.partner->isEmpty()
----
--

== Query Operation Specification

* Specification of query operation body.

Example:

[source,ocl]
----
context University::instructors() : Set(Professor)
body:
    self.departments.instructors->asSet()
----


[.impact]
== Plan

[arabic]
. Introduction
. Invariants
. Model Navigation
. Types and Operations
. Property Definition
. *Operation Specification*
. Advanced Topics
. Conclusion
. Appendix - Language Details

[.impact]
== Operation Specification


== Operation Specification

.OCL can be used to specify class operations:
* Approach inspired from Abstract Types.
* An operation is defined by:
** A signature;
** A precondition; and
** A postcondition.
* The precondition constraints the operation input set.
* The postcondition specifies the operation semantics.

== Operation Precondition

* A precondition is a constraint that must be verified *before* the execution of the operation.
* Specifies what clients must respect to call the operation.
* Represented by an OCL expression, preceded by `+pre:+`

[source,ocl]
----
-- Only professors older than 30 years can be added to the department:
context Department::add(p : Professor) : Integer
    pre old: p.age > 30
----


== Postconditions

* A postcondition is a constraint that must be verified *after* the execution of the operation.
* Specifies what the operation must accomplish.
* Represented by an OCL expression preceded by the keyword `+post:+`

[source,ocl]
----
context Student::age() : Integer
post correct: result = (today - birthday).years()
----

* The `+result+` operator gives access to the operation return value.


== Property Values

* Within a postcondition, there are *two* available values for each property:
** Its value *before* the operation execution.
** Its value *after* the operation execution.

[source,ocl]
----
context Person::birthday()
    post: age = age@pre + 1

context Professor::raise(v : Integer)
    post: self.wage = self.wage@pre + v
----

* The `+@pre+` operator gives access to a property’s value *before* the operation execution.


== Previous Values (1/2)

When the `+@pre+` value of a property is an object, all the values reached from this objects are new:

[source,ocl]
----
a.b@pre.c
        -- the old value of b, say X,
        -- and the new value of c of X

a.b@pre.c@pre
        -- the old value of b , say X,
        -- and the old value of c of X.
----

== Previous Values (2/2)

image::atpre.svg[align=center,width=800px]

[source,ocl]
----
a.b@pre.c -- the new value of b1.c :  c3 
a.b@pre.c@pre  -- the old value of b1.c : c1 
a.b.c -- the new value of b2.c : c2
----

== Plan

[arabic]
. Introduction
. Invariants
. Model Navigation
. Types and Operations
. Property Definition
. Operation Specification
. *Advanced Topics*
. Conclusion
. Appendix - Language Details

[.impact]
== Advanced Topics

Tuples, Messages, Constraint Inheritance


== Tuples

Definition

*Tuple:*

____
A Tuple is a finite sequence of objects or components, where each component is named. The component types are potentially different.
____

*Examples:*

[source,ocl]
----
Tuple {name:String = 'Martin', age:Integer = 42}
Tuple {name:'Colette', grades:Collection(Integer) = Set{12, 13, 9},
     diploma:String = 'Computer Science'}
----


== Tuple Syntax

* Types are optionals.
* The component order is not relevant.

*Equivalent expressions:*

[source,ocl]
----
Tuple {name: String = 'Martin', age: Integer = 42}
Tuple {name = 'Martin', age = 42}
Tuple {age = 42, name = 'Martin'}
----


== Tuple Component Initialization

* OCL expressions can be used to initialize tuple components:

[source,ocl]
----
context University def:
statistics : Set(Tuple(dpt : Department, studentNb:Integer,
                               graduated: Set(Student), average: Integer)) =
     department->collect(each |
       Tuple { dpt : Department = each,
           studentNb: Integer = each.students()->size(),
           graduated: Set(Student) = each.students()->select(graduated()),
           average: Integer = each.students()->collect(note)->avg()
          }
      )
----

== Tuple Component Access

* Component values are accessible through their names, using the dotted notation:

[source,ocl]
----
Tuple {name:String='Martin', age:Integer = 42}.age = 42
----

* The attribute `+statistics+` defined previously can be used within another OCL expression:

[source,ocl]
----
context University inv:
     statistics->sortedBy(average)->last().dpt.name = 'Computer Science'
     -- CS department has always the best students.
----


== Messages

OCL expressions can verify that a communication happened, using the «`+^+`» (hasSent) operator:

[source,ocl]
----
context Subject::hasChanged()
post:  observer^update(12, 14)
----

[.notes]
--
The expression `+observer^update(12, 14)+` evaluates to true if the message `+update+`, with the arguments 12 and 14 was sent to the object `+observer+`. The statement `+update()+` is either an operation from observer’s class, or a Signal. Obviously, the arguments 12 and 14 must conform to the operation’s parameters.
--

== Jokers

- When the arguments are not known, the expression can use the operator «`+?+`» (joker):

[source,ocl]
----
context Subject::hasChanged() post:  observer^update(? : Integer, ? : Integer)
----

== The «OclMessage» Type

* The operator «`+^^+`» (messages) allows an expression to access a sequence of sent messages:

[source,ocl]
----
context Subject::hasChanged()
post: let messages : Sequence(OclMessage) =
            observer^^update(? : Integer, ? : Integer) in
      messages->notEmpty() and
      messages->exists( m | m.i > 0 and m.j >= m.i )
----

== Returned Values

* The operator `+OclMessage::result()+` allows an expression to access an operation return value (signals do not return values).  
* The operator `+OclMessage::hasReturned()+` returns true if the operation returned a value.

[source,ocl]
----
context Person::giveSalary(amount : Integer) 
    post: let message : OclMessage = company^getMoney(amount) in 
    message.hasReturned() 
    -- getMoney was sent and returned 
    and message.result() 
    -- the getMoney call returned true
----

[.notes]
--
|note: Signal messages are asynchronous by definition, they do not have a return value.
|<!– ## Stéréotypes des contraintes
|Plusieurs stéréotypes sont définis en standard dans UML:
|- Invariants de classe: «invariant» - Pré-conditions: «precondition» - Post-conditions: «postcondition» - Définitions de propriétés: «definition»
|## Package context
|Il est possible de spécifier explicitement le nom du paquetage auquel appartient une contrainte:
|```ocl package Package::SubPackage context X inv: – some invariant
|context X::operation() pre: – some precondition endpackage ```
--

== Constraint Inheritance

*Liskov substitution principle (LSP)*

____
In an object-oriented program, if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e., an object of type T may be substituted with any object of a subtype S).
____


== Invariant Inheritance

.Consequence of the LSP on the invariants:
* Subclasses always inherit invariants.
* Subclasses can only reinforce an invariant.

== Pre- and Post-Condition Inheritance

.Consequences of the LSP on pre and postconditions:
* A precondition can only be relaxed (contrevariance)
* A postcondition can only be reinforced (covariance)

== Plan

. Introduction 
. Invariants 
. Model Navigation 
. Types and Operations
. Property Definition 
. Operation Specification 
. Advanced Topics 
. *Conclusion* 
. Appendix - Language Details

[.impact]
== Conclusion

== OCL Goals

.Design by contracts allows designers to: 
* be more precise. 
* improve documentation. 
* keep design independent from implementation. 
* Identify component’s responsibilities.


== OCL Usages

.OCL expressions can specify:
* Class invariants;
* Class attributes initialization;
* Class derived attributes;
* New class properties: attributes and _query_ operations;
* Class operations pre- and post-conditions;
* Transition guards;
* Transition pre and postconditions;

[.notes]
--
A _query_ operation is operation with no side effect.
--

== Modeling Advices

* Keep things simple: the goal of constraints is to improve the quality of a specification, and not to make it more complex.
* Always combine constraints with natural language: constraints are used to make comments less ambiguous and not to replace them.
* Use a tool.


== Usage

* Code generation
** Contract generation in Eiffel, Sather, Clojure, etc.
** Tool specific contract generation:
*** OVal http://oval.sourceforge.net/
*** Contracts for Java (Cofoja) https://github.com/nhatminhle/cofoja
*** Java Modeling Language (JML)
*** valid4j http://www.valid4j.org
* Enhanced test case generation.


== References

* The Object Constraint Language -– Jos Warmer, Anneke Kleppe.
* OCL home page: http://www.klasse.nl/ocl/
* OCL tools: http://www.um.es/giisw/ocltools
* OMG Specification v2.3.1 http://www.omg.org/spec/OCL/Current/
* OMG UML 2.5 Working Group.



== Tools

* Eclipse OCL. https://projects.eclipse.org/projects/modeling.mdt.ocl
* OCL Checker (Klasse Objecten)
* USE OCL (Mark Richters). http://useocl.sourceforge.net/w/
* Dresden OCL. http://www.dresden-ocl.org
* Octopus (Warmer & Kleppe). http://octopus.sourceforge.net/
  
== Plan
. Introduction 
. Invariants 
. Model Navigation 
. Types and Operations
. Property Definition 
. Operation Specification 
. Advanced Topics 
. Conclusion 
. *Appendix - Language Details*
 
[.impact]
== Appendix

Language Details

== Access to Class-level Properties

* Class-level properties are accessed through double-colons (`::`)

.Class-level attributes
[source,ocl]
----
context Professor inv:
    self.wage < Professor::maximumWage
----

.Class-level query operations:
[source,ocl]
----
context Professor inv:
    self.age() > Student::minimumAge()
----

== Access to Enumeration Literals and Nested States

* To avoid name conflicts, enumeration literals are preceded by the enumeration name and double-colons:

[source,ocl]
----
context Professor 
inv: self.title = Title::full implies self.wage > 10
----

* Nested states (from the attached state machine) are preceded by the container state name and double-colons:

[source,ocl]
----
context Department::add(p:Professor) 
pre:p.oclInState(Unavailable::Holydays) 
-- nested states
----

== Advanced Operations on Collections

[width="100%",cols="30%,70%",options="header",]
|===
|Operation | Behavior
|`+collectNested(<exp>)+` |Similar to `+collect()+`, but does not flatten the result if it is a collections of collections.
|`+closure()+` |Recursively evaluates and expression.
|`+iterate()+` |Generic operation that applies to any collection.
|===


== Collect Nested

Similar to `+collect()+`, without flattening collections of collections.

[source,ocl]
----
context University
    -- All university instructors, grouped by department:
    self.department->collectNested(instructors)
----

Collections of collections can be flattened with the `+flatten()+` operation:

[source,ocl]
----
    Set{Set{1, 2}, Set{3, 4}} ->flatten() = Set{1, 2, 3, 4}
----

== Closures

* The `+closure()+` operation recursively invokes an OCL expression over a _source_ and adds the successive results to the _source_.
* The iteration finishes when the expression evaluation returns an empty set.

Syntax:

[source,ocl]
----
source->closure(v : <class-name> | <expression-with-v>)
----

== Closure Example

image::family.svg[align=center,width=600px]

[source,ocl]
----
context Person
def descendants() : Set(Person) = self.children->closure(children)
----

== Iterate

Generic iterator operation on collections.

Syntax:

[source,ocl]
----
Collection(<T>)->iterate(<elm>: <T>; answer: T = <value> |
    <expr-with-elm-and-response>)
----

Examples:

[source,ocl]
----
context Department inv:
    self.instructors->select(age > 50)->notEmpty()

    -- equivalent expression:
    self.instructors->iterate(each: Professor;
        answer: Set(Professor) = Set {} |
            if each.age > 50 then answer.including(each)
            else answer endif) -> notEmpty()
----

== Other operations on Collections

[width="100%",cols="30%,70%",options="header",]
|===
|Operation | Behavior 
| `+includes(<elem>)+`, `+excludes(<elem>)+`| Checks if `+<elem>+` belongs (_resp_. not belongs) to the collection. 
| `+includesAll(<coll>)+`, `+excludesAll(<coll>)+` | Checks if all elements of `+<coll>+` belong (_resp_. not belong) to the collection. 
| `+union(<coll>)+`, `+intersection(<coll>)+` | Set operations. 
| `+asSet()+`, `+asBag()+`, `+asSequence()+`| Type conversion. 
| `+including(<elem>)+`, `+excluding(<elem>)+`| Creates a new collection that includes (_resp_. excludes) `+<elem>+`
|===

== Predefined Properties (1/2)

[width="100%",cols="70%,30%",options="header",]
|===
|Operation | Behavior
|`+oclIsTypeOf(t : OclType):Boolean+` |
|`+oclIsKindOf(t : OclType):Boolean+` |
|`+oclInState(s : OclState):Boolean+` |
|`+oclIsNew():Boolean+` |
|===


== Predefined Properties (1/2)

[width="100%",cols="70%,30%",options="header",]
|===
| Operation | Behavior
|`+oclIsUndefined():Boolean+` |
|`+oclIsInvalid():Boolean+` |
|`+oclAsType(t : Type):Type+` |
|`+allInstances():Set(T)+` |
|===

Examples:

[source,ocl]
----
context University
    inv: self.oclIsTypeOf(University)
    inv: not self.oclIsTypeOf(Department)
----

== Let...in (alias)

When an OCL sub-expression appears several times on a constraint, it is possible to use an *alias* to replace if:

Syntax:

[source,ocl]
----
let <alias> : <Type> = <ocl-expression> in <expression-with-alias>
----

Example:

[source,ocl]
----
context Person inv:
    let income : Integer = self.job.salary->sum() in
    if isUnemployed then
        income < 100
    else
        income >= 100
    endif
----

* Note that this is only an alias, not an assignment.

[.impact]
== Thank you for your attention!

[.text-small]
== License

[.font-size-64]
--
*Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)*

[.center]
.You are free to:
* *Share* — copy and redistribute the material in any medium or format
* *Adapt* — remix, transform, and build upon the material for any purpose, even commercially.

The licensor cannot revoke these freedoms as long as you follow the license terms.

[.center]
.Under the following terms:
* *Attribution* — You must give appropriate credit, provide a link to the license, and indicate if changes were made. You may do so in any reasonable manner, but not in any way that suggests the licensor endorses you or your use.
* *NonCommercial* — You may not use the material for commercial purposes.
* *ShareAlike* — If you remix, transform, or build upon the material, you must distribute your contributions under the same license as the original.

*No additional restrictions* — You may not apply legal terms or technological measures that legally restrict others from doing anything the license permits.
--
